<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sidekick_sat (sidekick.Sidekick_sat)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> – package <a href="../index.html">sidekick</a></nav><h1>Module <code>Sidekick_sat</code></h1><p>Main API</p></header><article id="module-Theory_intf"><a href="#module-Theory_intf" class="anchor"></a><code><span class="keyword">module </span><a href="Theory_intf/index.html">Theory_intf</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article id="module-Solver_types_intf"><a href="#module-Solver_types_intf" class="anchor"></a><code><span class="keyword">module </span><a href="Solver_types_intf/index.html">Solver_types_intf</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article id="module-Res"><a href="#module-Res" class="anchor"></a><code><span class="keyword">module </span><a href="Res/index.html">Res</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-S/index.html">S</a> = <a href="../Sidekick_sat__/Solver_intf/index.html#module-type-S">Sidekick_sat__.Solver_intf.S</a></code></article><dl><dt id="type-negated"><a href="#type-negated" class="anchor"></a><code><span class="keyword">type </span>negated</code><code><span class="keyword"> = </span><a href="Theory_intf/index.html#type-negated">Theory_intf.negated</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-negated.Negated" class="anchored"><td class="def constructor"><a href="#type-negated.Negated" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Negated</span></code></td></tr><tr id="type-negated.Same_sign" class="anchored"><td class="def constructor"><a href="#type-negated.Same_sign" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Same_sign</span></code></td></tr></table><code></code></dt><dt id="type-res"><a href="#type-res" class="anchor"></a><code><span class="keyword">type </span>('formula, 'proof) res</code><code><span class="keyword"> = </span>(<span class="type-var">'formula</span>, <span class="type-var">'proof</span>) <a href="Theory_intf/index.html#type-res">Theory_intf.res</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-res.Sat" class="anchored"><td class="def constructor"><a href="#type-res.Sat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Sat</span></code></td><td class="doc"><p>The current set of assumptions is satisfiable.</p></td></tr><tr id="type-res.Unsat" class="anchored"><td class="def constructor"><a href="#type-res.Unsat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unsat</span><span class="keyword"> of </span><span class="type-var">'formula</span> list<span class="keyword"> * </span><span class="type-var">'proof</span></code></td><td class="doc"><p>The current set of assumptions is *NOT* satisfiable, and here is a theory tautology (with its proof), for which every litteral is false under the current assumptions.</p></td></tr></table><code></code></dt><dd><p>Type returned by the theory. Formulas in the unsat clause must come from the current set of assumptions, i.e must have been encountered in a slice.</p></dd></dl><dl><dt id="type-sat_state"><a href="#type-sat_state" class="anchor"></a><code><span class="keyword">type </span>'form sat_state</code><code><span class="keyword"> = </span><span class="type-var">'form</span> <a href="../Sidekick_sat__/Solver_intf/index.html#type-sat_state">Sidekick_sat__.Solver_intf.sat_state</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-sat_state.Sat_state" class="anchored"><td class="def constructor"><a href="#type-sat_state.Sat_state" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Sat_state</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-sat_state.eval" class="anchored"><td class="def field"><a href="#type-sat_state.eval" class="anchor"></a><code>eval : <span class="type-var">'form</span> <span>&#8209;&gt;</span> bool;</code></td></tr><tr id="type-sat_state.eval_level" class="anchored"><td class="def field"><a href="#type-sat_state.eval_level" class="anchor"></a><code>eval_level : <span class="type-var">'form</span> <span>&#8209;&gt;</span> bool<span class="keyword"> * </span>int;</code></td></tr><tr id="type-sat_state.iter_trail" class="anchored"><td class="def field"><a href="#type-sat_state.iter_trail" class="anchor"></a><code>iter_trail : (<span class="type-var">'form</span> <span>&#8209;&gt;</span> unit) <span>&#8209;&gt;</span> unit;</code></td></tr></table><code>}</code><code></code></td></tr></table><code></code></dt><dt id="type-unsat_state"><a href="#type-unsat_state" class="anchor"></a><code><span class="keyword">type </span>('clause, 'proof) unsat_state</code><code><span class="keyword"> = </span>(<span class="type-var">'clause</span>, <span class="type-var">'proof</span>) <a href="../Sidekick_sat__/Solver_intf/index.html#type-unsat_state">Sidekick_sat__.Solver_intf.unsat_state</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-unsat_state.Unsat_state" class="anchored"><td class="def constructor"><a href="#type-unsat_state.Unsat_state" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unsat_state</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-unsat_state.unsat_conflict" class="anchored"><td class="def field"><a href="#type-unsat_state.unsat_conflict" class="anchor"></a><code>unsat_conflict : unit <span>&#8209;&gt;</span> <span class="type-var">'clause</span>;</code></td></tr><tr id="type-unsat_state.get_proof" class="anchored"><td class="def field"><a href="#type-unsat_state.get_proof" class="anchor"></a><code>get_proof : unit <span>&#8209;&gt;</span> <span class="type-var">'proof</span>;</code></td></tr></table><code>}</code><code></code></td></tr></table><code></code></dt><dt id="type-export"><a href="#type-export" class="anchor"></a><code><span class="keyword">type </span>'clause export</code><code><span class="keyword"> = </span><span class="type-var">'clause</span> <a href="../Sidekick_sat__/Solver_intf/index.html#type-export">Sidekick_sat__.Solver_intf.export</a></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-export.hyps" class="anchored"><td class="def field"><a href="#type-export.hyps" class="anchor"></a><code>hyps : <span class="type-var">'clause</span> <a href="../Sidekick_util/Vec/index.html#type-t">Sidekick_util.Vec.t</a>;</code></td></tr><tr id="type-export.history" class="anchored"><td class="def field"><a href="#type-export.history" class="anchor"></a><code>history : <span class="type-var">'clause</span> <a href="../Sidekick_util/Vec/index.html#type-t">Sidekick_util.Vec.t</a>;</code></td></tr><tr id="type-export.local" class="anchored"><td class="def field"><a href="#type-export.local" class="anchor"></a><code>local : <span class="type-var">'clause</span> <a href="../Sidekick_util/Vec/index.html#type-t">Sidekick_util.Vec.t</a>;</code></td></tr></table><code>}</code><code></code></dt><dt id="type-actions"><a href="#type-actions" class="anchor"></a><code><span class="keyword">type </span>('form, 'proof) actions</code><code><span class="keyword"> = </span>(<span class="type-var">'form</span>, <span class="type-var">'proof</span>) <a href="Theory_intf/index.html#type-actions">Theory_intf.actions</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-actions.Actions" class="anchored"><td class="def constructor"><a href="#type-actions.Actions" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Actions</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-actions.push_persistent" class="anchored"><td class="def field"><a href="#type-actions.push_persistent" class="anchor"></a><code>push_persistent : <span class="type-var">'form</span> <a href="../Sidekick_util/IArray/index.html#type-t">Sidekick_util.IArray.t</a> <span>&#8209;&gt;</span> <span class="type-var">'proof</span> <span>&#8209;&gt;</span> unit;</code></td></tr><tr id="type-actions.push_local" class="anchored"><td class="def field"><a href="#type-actions.push_local" class="anchor"></a><code>push_local : <span class="type-var">'form</span> <a href="../Sidekick_util/IArray/index.html#type-t">Sidekick_util.IArray.t</a> <span>&#8209;&gt;</span> <span class="type-var">'proof</span> <span>&#8209;&gt;</span> unit;</code></td></tr><tr id="type-actions.on_backtrack" class="anchored"><td class="def field"><a href="#type-actions.on_backtrack" class="anchor"></a><code>on_backtrack : (unit <span>&#8209;&gt;</span> unit) <span>&#8209;&gt;</span> unit;</code></td></tr><tr id="type-actions.propagate" class="anchored"><td class="def field"><a href="#type-actions.propagate" class="anchor"></a><code>propagate : <span class="type-var">'form</span> <span>&#8209;&gt;</span> <span class="type-var">'form</span> list <span>&#8209;&gt;</span> <span class="type-var">'proof</span> <span>&#8209;&gt;</span> unit;</code></td></tr></table><code>}</code><code></code></td></tr></table><code></code></dt><dt id="type-slice_actions"><a href="#type-slice_actions" class="anchor"></a><code><span class="keyword">type </span>('form, 'proof) slice_actions</code><code><span class="keyword"> = </span>(<span class="type-var">'form</span>, <span class="type-var">'proof</span>) <a href="Theory_intf/index.html#type-slice_actions">Theory_intf.slice_actions</a></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-slice_actions.Slice_acts" class="anchored"><td class="def constructor"><a href="#type-slice_actions.Slice_acts" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Slice_acts</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-slice_actions.slice_iter" class="anchored"><td class="def field"><a href="#type-slice_actions.slice_iter" class="anchor"></a><code>slice_iter : (<span class="type-var">'form</span> <span>&#8209;&gt;</span> unit) <span>&#8209;&gt;</span> unit;</code></td></tr></table><code>}</code><code></code></td></tr></table><code></code></dt></dl><article id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module </span><a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-E/index.html">E</a> : <a href="Theory_intf/index.html#module-type-S">Theory_intf.S</a>) -&gt; <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article></body></html>