<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CC (sidekick-bin.Sidekick_smtlib__.Process.Solver.Solver_internal.CC)</title><link rel="stylesheet" href="../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">sidekick-bin</a> &#x00BB; <a href="../../../../index.html">Sidekick_smtlib__</a> &#x00BB; <a href="../../../index.html">Process</a> &#x00BB; <a href="../../index.html">Solver</a> &#x00BB; <a href="../index.html">Solver_internal</a> &#x00BB; CC</nav><h1>Module <code>Solver_internal.CC</code></h1></header><div class="spec module" id="module-CC_A"><a href="#module-CC_A" class="anchor"></a><code><span class="keyword">module</span> CC_A = <a href="../index.html#module-CC_A">CC_A</a></code></div><div class="spec module" id="module-A"><a href="#module-A" class="anchor"></a><code><span class="keyword">module</span> A = <a href="CC_A/index.html#module-A">CC_A.A</a></code></div><dl><dt class="spec type" id="type-term_state"><a href="#type-term_state" class="anchor"></a><code><span class="keyword">type</span> term_state</code><code> = <a href="CC_A/A/Term/index.html#type-state">A.Term.state</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="CC_A/A/Term/index.html#type-t">A.Term.t</a></code></dt><dt class="spec type" id="type-fun_"><a href="#type-fun_" class="anchor"></a><code><span class="keyword">type</span> fun_</code><code> = <a href="CC_A/A/Fun/index.html#type-t">A.Fun.t</a></code></dt><dt class="spec type" id="type-lit"><a href="#type-lit" class="anchor"></a><code><span class="keyword">type</span> lit</code><code> = <a href="CC_A/Lit/index.html#type-t">CC_A.Lit.t</a></code></dt><dt class="spec type" id="type-proof"><a href="#type-proof" class="anchor"></a><code><span class="keyword">type</span> proof</code><code> = <a href="CC_A/A/Proof/index.html#type-t">A.Proof.t</a></code></dt><dt class="spec type" id="type-actions"><a href="#type-actions" class="anchor"></a><code><span class="keyword">type</span> actions</code><code> = <a href="CC_A/Actions/index.html#type-t">CC_A.Actions.t</a></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Global state of the congruence closure</p></dd></dl><dl><dt class="spec module" id="module-N"><a href="#module-N" class="anchor"></a><code><span class="keyword">module</span> <a href="N/index.html">N</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An equivalence class is a set of terms that are currently equal in the partial model built by the solver. The class is represented by a collection of nodes, one of which is distinguished and is called the &quot;representative&quot;.</p></dd></dl><div class="spec module" id="module-Expl"><a href="#module-Expl" class="anchor"></a><code><span class="keyword">module</span> <a href="Expl/index.html">Expl</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type</span> node</code><code> = <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>A node of the congruence closure</p></dd></dl><dl><dt class="spec type" id="type-repr"><a href="#type-repr" class="anchor"></a><code><span class="keyword">type</span> repr</code><code> = <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>Node that is currently a representative</p></dd></dl><dl><dt class="spec type" id="type-explanation"><a href="#type-explanation" class="anchor"></a><code><span class="keyword">type</span> explanation</code><code> = <a href="Expl/index.html#type-t">Expl.t</a></code></dt></dl><aside><p>Accessors</p></aside><dl><dt class="spec value" id="val-term_state"><a href="#val-term_state" class="anchor"></a><code><span class="keyword">val</span> term_state : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term_state">term_state</a></code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-repr">repr</a></code></dt><dd><p>Current representative</p></dd></dl><dl><dt class="spec value" id="val-add_term"><a href="#val-add_term" class="anchor"></a><code><span class="keyword">val</span> add_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dd><p>Add the term to the congruence closure, if not present already. Will be backtracked.</p></dd></dl><dl><dt class="spec type" id="type-ev_on_merge"><a href="#type-ev_on_merge" class="anchor"></a><code><span class="keyword">type</span> ev_on_merge</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-ev_on_new_term"><a href="#type-ev_on_new_term" class="anchor"></a><code><span class="keyword">type</span> ev_on_new_term</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-ev_on_conflict"><a href="#type-ev_on_conflict" class="anchor"></a><code><span class="keyword">type</span> ev_on_conflict</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-ev_on_propagate"><a href="#type-ev_on_propagate" class="anchor"></a><code><span class="keyword">type</span> ev_on_propagate</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list) <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : ?&#8288;stat:<a href="../../../../../../sidekick/Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a> <span>&#45;&gt;</span> ?&#8288;on_merge:<a href="index.html#type-ev_on_merge">ev_on_merge</a> list <span>&#45;&gt;</span> ?&#8288;on_new_term:<a href="index.html#type-ev_on_new_term">ev_on_new_term</a> list <span>&#45;&gt;</span> ?&#8288;on_conflict:<a href="index.html#type-ev_on_conflict">ev_on_conflict</a> list <span>&#45;&gt;</span> ?&#8288;on_propagate:<a href="index.html#type-ev_on_propagate">ev_on_propagate</a> list <span>&#45;&gt;</span> ?&#8288;size:[ `Small | `Big ] <span>&#45;&gt;</span> <a href="index.html#type-term_state">term_state</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a new congruence closure.</p></dd></dl><dl><dt class="spec value" id="val-on_merge"><a href="#val-on_merge" class="anchor"></a><code><span class="keyword">val</span> on_merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_merge">ev_on_merge</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a function to be called when two classes are merged</p></dd></dl><dl><dt class="spec value" id="val-on_new_term"><a href="#val-on_new_term" class="anchor"></a><code><span class="keyword">val</span> on_new_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_new_term">ev_on_new_term</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a function to be called when a new node is created</p></dd></dl><dl><dt class="spec value" id="val-on_conflict"><a href="#val-on_conflict" class="anchor"></a><code><span class="keyword">val</span> on_conflict : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_conflict">ev_on_conflict</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Called when the congruence closure finds a conflict</p></dd></dl><dl><dt class="spec value" id="val-on_propagate"><a href="#val-on_propagate" class="anchor"></a><code><span class="keyword">val</span> on_propagate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_propagate">ev_on_propagate</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Called when the congruence closure propagates a literal</p></dd></dl><dl><dt class="spec value" id="val-set_as_lit"><a href="#val-set_as_lit" class="anchor"></a><code><span class="keyword">val</span> set_as_lit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>map the given node to a literal.</p></dd></dl><dl><dt class="spec value" id="val-find_t"><a href="#val-find_t" class="anchor"></a><code><span class="keyword">val</span> find_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-repr">repr</a></code></dt><dd><p>Current representative of the term.</p><dl><dt>raises Not_found</dt><dd><p>if the term is not already <code>add</code>-ed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span class="keyword">val</span> add_seq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> Iter.t <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a sequence of terms to the congruence closure</p></dd></dl><dl><dt class="spec value" id="val-all_classes"><a href="#val-all_classes" class="anchor"></a><code><span class="keyword">val</span> all_classes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-repr">repr</a> Iter.t</code></dt><dd><p>All current classes. This is costly, only use if there is no other solution</p></dd></dl><dl><dt class="spec value" id="val-assert_lit"><a href="#val-assert_lit" class="anchor"></a><code><span class="keyword">val</span> assert_lit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Given a literal, assume it in the congruence closure and propagate its consequences. Will be backtracked.</p><p>Useful for the theory combination or the SAT solver's functor</p></dd></dl><dl><dt class="spec value" id="val-assert_lits"><a href="#val-assert_lits" class="anchor"></a><code><span class="keyword">val</span> assert_lits : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> Iter.t <span>&#45;&gt;</span> unit</code></dt><dd><p>Addition of many literals</p></dd></dl><dl><dt class="spec value" id="val-raise_conflict_from_expl"><a href="#val-raise_conflict_from_expl" class="anchor"></a><code><span class="keyword">val</span> raise_conflict_from_expl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Raise a conflict with the given explanation it must be a theory tautology that <code>expl ==&gt; absurd</code>. To be used in theories.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Merge these two nodes given this explanation. It must be a theory tautology that <code>expl ==&gt; n1 = n2</code>. To be used in theories.</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Perform all pending operations done via <code>assert_eq</code>, <a href="index.html#val-assert_lit"><code>assert_lit</code></a>, etc. Will use the <a href="index.html#type-actions"><code>actions</code></a> to propagate literals, declare conflicts, etc.</p></dd></dl><dl><dt class="spec value" id="val-push_level"><a href="#val-push_level" class="anchor"></a><code><span class="keyword">val</span> push_level : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Push backtracking level</p></dd></dl><dl><dt class="spec value" id="val-pop_levels"><a href="#val-pop_levels" class="anchor"></a><code><span class="keyword">val</span> pop_levels : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Restore to state <code>n</code> calls to <code>push_level</code> earlier. Used during backtracking.</p></dd></dl><dl><dt class="spec value" id="val-get_model"><a href="#val-get_model" class="anchor"></a><code><span class="keyword">val</span> get_model : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> Iter.t Iter.t</code></dt><dd><p>get all the equivalence classes so they can be merged in the model</p></dd></dl></div></body></html>