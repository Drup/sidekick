<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Theory_intf (sidekick.Sidekick_sat.Theory_intf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">sidekick</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Sidekick_sat.Theory_intf</span></h1></header><div class="doc"><p>SMT Theory</p><p>This module defines what a theory must implement in order to
be used in an SMT solver.</p></div><div class="spec type" id="type-negated"><a href="#type-negated" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>negated</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-negated.Negated" class="anchored"><td class="def constructor"><a href="#type-negated.Negated" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Negated</span></code></td><td class="doc"><p>(** changed sign *)</p></td></tr><tr id="type-negated.Same_sign" class="anchored"><td class="def constructor"><a href="#type-negated.Same_sign" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Same_sign</span></code></td><td class="doc"><p>(** kept sign *)</p></td></tr></table><code></code></div><div class="doc"><p>This type is used during the normalisation of formulas.
See <span class="xref-unresolved" title="unresolved reference to &quot;Expr_intf.S.norm&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Expr_intf.S&quot;">Expr_intf.S</span>.norm</span> for more details.</p></div></div><div class="spec type" id="type-res"><a href="#type-res" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('formula, 'proof) res</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-res.Sat" class="anchored"><td class="def constructor"><a href="#type-res.Sat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Sat</span></code></td><td class="doc"><p>(** The current set of assumptions is satisfiable. *)</p></td></tr><tr id="type-res.Unsat" class="anchored"><td class="def constructor"><a href="#type-res.Unsat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unsat</span><span class="keyword"> of </span><span class="type-var">'formula</span> list<span class="keyword"> * </span><span class="type-var">'proof</span></code></td><td class="doc"><p>(** The current set of assumptions is *NOT* satisfiable, and here is a
theory tautology (with its proof), for which every literal is false
under the current assumptions. *)</p></td></tr></table><code></code></div><div class="doc"><p>Type returned by the theory. Formulas in the unsat clause must come from the
current set of assumptions, i.e must have been encountered in a slice.</p></div></div><div class="spec type" id="type-actions"><a href="#type-actions" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('form, 'proof) actions</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-actions.Actions" class="anchored"><td class="def constructor"><a href="#type-actions.Actions" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Actions</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-actions.push_persistent" class="anchored"><td class="def field"><a href="#type-actions.push_persistent" class="anchor"></a><code>push_persistent : <span class="type-var">'form</span> <a href="../../Sidekick_util/IArray/index.html#type-t">Sidekick_util.IArray.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'proof</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** Allows to add a persistent clause to the solver. *)</p></td></tr><tr id="type-actions.push_local" class="anchored"><td class="def field"><a href="#type-actions.push_local" class="anchor"></a><code>push_local : <span class="type-var">'form</span> <a href="../../Sidekick_util/IArray/index.html#type-t">Sidekick_util.IArray.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'proof</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** Allows to add a local clause to the solver. The clause
will be removed after backtracking. *)</p></td></tr><tr id="type-actions.on_backtrack" class="anchored"><td class="def field"><a href="#type-actions.on_backtrack" class="anchor"></a><code>on_backtrack : (unit <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** <code class="code">on_backtrack f</code> calls <code class="code">f</code> when the main solver backtracks *)</p></td></tr><tr id="type-actions.propagate" class="anchored"><td class="def field"><a href="#type-actions.propagate" class="anchor"></a><code>propagate : <span class="type-var">'form</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'form</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'proof</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** <code class="code">propagate lit causes proof</code> informs the solver to propagate <code class="code">lit</code>, with the reason
that the clause <code class="code">causes =&gt; lit</code> is a theory tautology. It is faster than pushing
the associated clause but the clause will not be remembered by the sat solver,
i.e it will not be used by the solver to do boolean propagation. *)</p></td></tr></table><code>}</code><code></code></td></tr></table><code></code></div><div class="doc"><p>Actions given to the theory during initialization, to be used
at any time</p></div></div><div class="spec type" id="type-slice_actions"><a href="#type-slice_actions" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('form, 'proof) slice_actions</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-slice_actions.Slice_acts" class="anchored"><td class="def constructor"><a href="#type-slice_actions.Slice_acts" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Slice_acts</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-slice_actions.slice_iter" class="anchored"><td class="def field"><a href="#type-slice_actions.slice_iter" class="anchor"></a><code>slice_iter : (<span class="type-var">'form</span> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** iterate on the slice of the trail *)</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>(** The type for a slice. Slices are some kind of view of the current
propagation queue. They allow to look at the propagated literals,
and to add new clauses to the solver. *)</p></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><h3>Signature for theories to be given to the Solver.</h3></div></div></body></html>