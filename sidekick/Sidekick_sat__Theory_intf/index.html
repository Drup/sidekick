<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sidekick_sat__Theory_intf (sidekick.Sidekick_sat__Theory_intf)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> â€“ package <a href="../index.html">sidekick</a></nav><h1>Module <code>Sidekick_sat__Theory_intf</code></h1><p>SMT Theory</p><p>This module defines what a theory must implement in order to be used in an SMT solver.</p></header><dl><dt id="type-negated"><a href="#type-negated" class="anchor"></a><code><span class="keyword">type </span>negated</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-negated.Negated" class="anchored"><td class="def constructor"><a href="#type-negated.Negated" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Negated</span></code></td><td class="doc"><p>changed sign</p></td></tr><tr id="type-negated.Same_sign" class="anchored"><td class="def constructor"><a href="#type-negated.Same_sign" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Same_sign</span></code></td><td class="doc"><p>kept sign</p></td></tr></table><code></code></dt><dd><p>This type is used during the normalisation of formulas. See <span class="xref-unresolved" title="unresolved reference to &quot;Expr_intf.S.norm&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Expr_intf.S&quot;"><code>Expr_intf</code>.S</span>.norm</span> for more details.</p></dd></dl><dl><dt id="type-res"><a href="#type-res" class="anchor"></a><code><span class="keyword">type </span>('formula, 'proof) res</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-res.Sat" class="anchored"><td class="def constructor"><a href="#type-res.Sat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Sat</span></code></td><td class="doc"><p>The current set of assumptions is satisfiable.</p></td></tr><tr id="type-res.Unsat" class="anchored"><td class="def constructor"><a href="#type-res.Unsat" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Unsat</span><span class="keyword"> of </span><span class="type-var">'formula</span> list<span class="keyword"> * </span><span class="type-var">'proof</span></code></td><td class="doc"><p>The current set of assumptions is *NOT* satisfiable, and here is a theory tautology (with its proof), for which every litteral is false under the current assumptions.</p></td></tr></table><code></code></dt><dd><p>Type returned by the theory. Formulas in the unsat clause must come from the current set of assumptions, i.e must have been encountered in a slice.</p></dd></dl><dl><dt id="type-actions"><a href="#type-actions" class="anchor"></a><code><span class="keyword">type </span>('form, 'proof) actions</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-actions.Actions" class="anchored"><td class="def constructor"><a href="#type-actions.Actions" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Actions</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-actions.push_persistent" class="anchored"><td class="def field"><a href="#type-actions.push_persistent" class="anchor"></a><code>push_persistent : <span class="type-var">'form</span> <a href="../Sidekick_util/IArray/index.html#type-t">Sidekick_util.IArray.t</a> <span>&#8209;&gt;</span> <span class="type-var">'proof</span> <span>&#8209;&gt;</span> unit;</code></td><td class="doc"><p>Allows to add a persistent clause to the solver.</p></td></tr><tr id="type-actions.push_local" class="anchored"><td class="def field"><a href="#type-actions.push_local" class="anchor"></a><code>push_local : <span class="type-var">'form</span> <a href="../Sidekick_util/IArray/index.html#type-t">Sidekick_util.IArray.t</a> <span>&#8209;&gt;</span> <span class="type-var">'proof</span> <span>&#8209;&gt;</span> unit;</code></td><td class="doc"><p>Allows to add a local clause to the solver. The clause will be removed after backtracking.</p></td></tr><tr id="type-actions.on_backtrack" class="anchored"><td class="def field"><a href="#type-actions.on_backtrack" class="anchor"></a><code>on_backtrack : (unit <span>&#8209;&gt;</span> unit) <span>&#8209;&gt;</span> unit;</code></td><td class="doc"><p><code>on_backtrack f</code> calls <code>f</code> when the main solver backtracks</p></td></tr><tr id="type-actions.propagate" class="anchored"><td class="def field"><a href="#type-actions.propagate" class="anchor"></a><code>propagate : <span class="type-var">'form</span> <span>&#8209;&gt;</span> <span class="type-var">'form</span> list <span>&#8209;&gt;</span> <span class="type-var">'proof</span> <span>&#8209;&gt;</span> unit;</code></td><td class="doc"><p><code>propagate lit causes proof</code> informs the solver to propagate <code>lit</code>, with the reason that the clause <code>causes =&gt; lit</code> is a theory tautology. It is faster than pushing the associated clause but the clause will not be remembered by the sat solver, i.e it will not be used by the solver to do boolean propagation.</p></td></tr></table><code>}</code><code></code></td></tr></table><code></code></dt><dd><p>Actions given to the theory during initialization, to be used at any time</p></dd></dl><dl><dt id="type-slice_actions"><a href="#type-slice_actions" class="anchor"></a><code><span class="keyword">type </span>('form, 'proof) slice_actions</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-slice_actions.Slice_acts" class="anchored"><td class="def constructor"><a href="#type-slice_actions.Slice_acts" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Slice_acts</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-slice_actions.slice_iter" class="anchored"><td class="def field"><a href="#type-slice_actions.slice_iter" class="anchor"></a><code>slice_iter : (<span class="type-var">'form</span> <span>&#8209;&gt;</span> unit) <span>&#8209;&gt;</span> unit;</code></td><td class="doc"><p>iterate on the slice of the trail</p></td></tr></table><code>}</code><code></code></td><td class="doc"><p>The type for a slice. Slices are some kind of view of the current propagation queue. They allow to look at the propagated literals, and to add new clauses to the solver.</p></td></tr></table><code></code></dt></dl><article id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-S/index.html">S</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article></body></html>