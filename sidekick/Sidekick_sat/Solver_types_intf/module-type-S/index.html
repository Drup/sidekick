<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (sidekick.Sidekick_sat.Solver_types_intf.S)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../../index.html">sidekick</a></span></nav><header><h1><span class="keyword">Module type</span> <span class="module-path">Sidekick_sat.Solver_types_intf.S</span></h1></header><p>The signatures of clauses used in the Solver.</p><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>State for creating new terms, literals, clauses</p></div></div><div class="spec val" id="val-create"><a href="#val-create" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create : ?&#8288;size:[ `Tiny | `Small | `Big ] <span class="keyword">&#8209;&gt;</span> unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><h3>Type definitions</h3><div class="spec type" id="type-formula"><a href="#type-formula" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>formula</code><code></code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-proof"><a href="#type-proof" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>proof</code><code></code><code></code></div><div class="doc"><p>The types of formulas and proofs. All of these are user-provided.</p></div></div><div class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>var</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-var.vid" class="anchored"><td class="def field"><a href="#type-var.vid" class="anchor"></a><code>vid : int;</code></td><td class="doc"><p>(** Unique identifier *)</p></td></tr><tr id="type-var.pa" class="anchored"><td class="def field"><a href="#type-var.pa" class="anchor"></a><code>pa : <a href="index.html#type-atom">atom</a>;</code></td><td class="doc"><p>(** Link for the positive atom *)</p></td></tr><tr id="type-var.na" class="anchored"><td class="def field"><a href="#type-var.na" class="anchor"></a><code>na : <a href="index.html#type-atom">atom</a>;</code></td><td class="doc"><p>(** Link for the negative atom *)</p></td></tr><tr id="type-var.v_fields" class="anchored"><td class="def field"><a href="#type-var.v_fields" class="anchor"></a><code><span class="keyword">mutable </span>v_fields : <a href="../Var_fields/index.html#type-t">Var_fields.t</a>;</code></td><td class="doc"><p>(** bool fields *)</p></td></tr><tr id="type-var.v_level" class="anchored"><td class="def field"><a href="#type-var.v_level" class="anchor"></a><code><span class="keyword">mutable </span>v_level : int;</code></td><td class="doc"><p>(** Level of decision/propagation *)</p></td></tr><tr id="type-var.v_idx" class="anchored"><td class="def field"><a href="#type-var.v_idx" class="anchor"></a><code><span class="keyword">mutable </span>v_idx : int;</code></td><td class="doc"><p>(** rank in variable heap *)</p></td></tr><tr id="type-var.v_weight" class="anchored"><td class="def field"><a href="#type-var.v_weight" class="anchor"></a><code><span class="keyword">mutable </span>v_weight : float;</code></td><td class="doc"><p>(** Variable weight (for the heap) *)</p></td></tr><tr id="type-var.reason" class="anchored"><td class="def field"><a href="#type-var.reason" class="anchor"></a><code><span class="keyword">mutable </span>reason : <a href="index.html#type-reason">reason</a> option;</code></td><td class="doc"><p>(** The reason for propagation/decision of the literal *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-atom"><a href="#type-atom" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>atom</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-atom.aid" class="anchored"><td class="def field"><a href="#type-atom.aid" class="anchor"></a><code>aid : int;</code></td><td class="doc"><p>(** Unique identifier *)</p></td></tr><tr id="type-atom.var" class="anchored"><td class="def field"><a href="#type-atom.var" class="anchor"></a><code>var : <a href="index.html#type-var">var</a>;</code></td><td class="doc"><p>(** Link for the parent variable *)</p></td></tr><tr id="type-atom.neg" class="anchored"><td class="def field"><a href="#type-atom.neg" class="anchor"></a><code>neg : <a href="index.html#type-atom">atom</a>;</code></td><td class="doc"><p>(** Link for the negation of the atom *)</p></td></tr><tr id="type-atom.lit" class="anchored"><td class="def field"><a href="#type-atom.lit" class="anchor"></a><code>lit : <a href="index.html#type-formula">formula</a>;</code></td><td class="doc"><p>(** Wrapped formula *)</p></td></tr><tr id="type-atom.is_true" class="anchored"><td class="def field"><a href="#type-atom.is_true" class="anchor"></a><code><span class="keyword">mutable </span>is_true : bool;</code></td><td class="doc"><p>(** Is the atom true ? Conversely, the atom
is false iff a.neg.is_true *)</p></td></tr><tr id="type-atom.watched" class="anchored"><td class="def field"><a href="#type-atom.watched" class="anchor"></a><code><span class="keyword">mutable </span>watched : <a href="index.html#type-clause">clause</a> <a href="../../../Sidekick_util/Vec/index.html#type-t">Sidekick_util.Vec.t</a>;</code></td><td class="doc"><p>(** The vector of clauses that watch this atom *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>Atoms and variables wrap theory formulas. They exist in the form of
triplet: a variable and two atoms. For a formula <code class="code">f</code> in normal form,
the variable v points to the positive atom <code class="code">a</code> which wraps <code class="code">f</code>, while
<code class="code">a.neg</code> wraps the theory negation of <code class="code">f</code>.</p></div></div><div class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>clause</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-clause.name" class="anchored"><td class="def field"><a href="#type-clause.name" class="anchor"></a><code>name : int;</code></td><td class="doc"><p>(** Clause name, mainly for printing, unique. *)</p></td></tr><tr id="type-clause.tag" class="anchored"><td class="def field"><a href="#type-clause.tag" class="anchor"></a><code>tag : int option;</code></td><td class="doc"><p>(** User-provided tag for clauses. *)</p></td></tr><tr id="type-clause.atoms" class="anchored"><td class="def field"><a href="#type-clause.atoms" class="anchor"></a><code>atoms : <a href="index.html#type-atom">atom</a> array;</code></td><td class="doc"><p>(** The atoms that constitute the clause. *)</p></td></tr><tr id="type-clause.cpremise" class="anchored"><td class="def field"><a href="#type-clause.cpremise" class="anchor"></a><code><span class="keyword">mutable </span>cpremise : <a href="index.html#type-premise">premise</a>;</code></td><td class="doc"><p>(** The premise of the clause, i.e. the justification
of why the clause must be satisfied. *)</p></td></tr><tr id="type-clause.activity" class="anchored"><td class="def field"><a href="#type-clause.activity" class="anchor"></a><code><span class="keyword">mutable </span>activity : float;</code></td><td class="doc"><p>(** Clause activity, used for the heap heuristics. *)</p></td></tr><tr id="type-clause.c_flags" class="anchored"><td class="def field"><a href="#type-clause.c_flags" class="anchor"></a><code><span class="keyword">mutable </span>c_flags : <a href="../C_fields/index.html#type-t">C_fields.t</a>;</code></td><td class="doc"><p>(** Boolean flags for the clause *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>The type of clauses. Each clause generated should be true, i.e. enforced
by the current problem (for more information, see the cpremise field).</p></div></div><div class="spec type" id="type-reason"><a href="#type-reason" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>reason</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-reason.Decision" class="anchored"><td class="def constructor"><a href="#type-reason.Decision" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Decision</span></code></td><td class="doc"><p>(** The atom has been decided by the sat solver *)</p></td></tr><tr id="type-reason.Bcp" class="anchored"><td class="def constructor"><a href="#type-reason.Bcp" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Bcp</span><span class="keyword"> of </span><a href="index.html#type-clause">clause</a></code></td><td class="doc"><p>(** The atom has been propagated by the given clause *)</p></td></tr></table><code></code></div><div class="doc"><p>Reasons of propagation/decision of atoms.</p></div></div><div class="spec type" id="type-premise"><a href="#type-premise" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>premise</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-premise.Hyp" class="anchored"><td class="def constructor"><a href="#type-premise.Hyp" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Hyp</span></code></td><td class="doc"><p>(** The clause is a hypothesis, provided by the user. *)</p></td></tr><tr id="type-premise.Local" class="anchored"><td class="def constructor"><a href="#type-premise.Local" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Local</span></code></td><td class="doc"><p>(** The clause is a 1-atom clause,
where the atom is a local assumption *)</p></td></tr><tr id="type-premise.Lemma" class="anchored"><td class="def constructor"><a href="#type-premise.Lemma" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lemma</span><span class="keyword"> of </span><a href="index.html#type-proof">proof</a></code></td><td class="doc"><p>(** The clause is a theory-provided tautology, with
the given proof. *)</p></td></tr><tr id="type-premise.History" class="anchored"><td class="def constructor"><a href="#type-premise.History" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">History</span><span class="keyword"> of </span><a href="index.html#type-clause">clause</a> list</code></td><td class="doc"><p>(** The clause can be obtained by resolution of the clauses
in the list. If the list has a single element <code class="code">c</code> , then
the clause can be obtained by simplifying <code class="code">c</code> (i.e
eliminating doublons in its atom list).
For a premise <code class="code">History [a_1 :: ... :: a_n]</code> (<code class="code">n &gt; 0</code>)
the clause is obtained by performing resolution of
<code class="code">a_1</code> with <code class="code">a_2</code>, and then performing a resolution step between
the result and <code class="code">a_3</code>, etc...
Of course, each of the clause <code class="code">a_i</code> also has its own premise. *)</p></td></tr></table><code></code></div><div class="doc"><p>Premises for clauses. Indeed each clause generated during a run of the solver
should be satisfied, the premise is the justification of why it should be
satisfied by the solver.</p></div></div><h3>Decisions and propagations</h3><h3>Elements</h3><div class="spec val" id="val-nb_elt"><a href="#val-nb_elt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>nb_elt : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div><div class="spec val" id="val-get_elt"><a href="#val-get_elt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_elt : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-var">var</a></code></div><div class="doc"></div></div><div class="spec val" id="val-iter_elt"><a href="#val-iter_elt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>iter_elt : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<a href="index.html#type-var">var</a> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Read access to the vector of variables created</p></div></div><h3>Variables, Literals &amp; Clauses</h3><div class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>state</code><code><span class="keyword"> = </span><a href="index.html#type-t">t</a></code><code></code></div><div class="doc"></div></div><div class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Atom"><a href="#module-Atom" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Atom/index.html">Atom</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Clause"><a href="#module-Clause" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Clause/index.html">Clause</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Formula"><a href="#module-Formula" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Formula/index.html">Formula</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div></body></html>