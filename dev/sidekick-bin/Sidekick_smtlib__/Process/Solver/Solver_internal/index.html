<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solver_internal (sidekick-bin.Sidekick_smtlib__.Process.Solver.Solver_internal)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">sidekick-bin</a> &#x00BB; <a href="../../../index.html">Sidekick_smtlib__</a> &#x00BB; <a href="../../index.html">Process</a> &#x00BB; <a href="../index.html">Solver</a> &#x00BB; Solver_internal</nav><h1>Module <code>Solver.Solver_internal</code></h1><p>Internal solver, available to theories.</p><nav class="toc"><ul><li><a href="#simplifiers">Simplifiers</a></li><li><a href="#hooks-for-the-theory">hooks for the theory</a></li><li><a href="#preprocessors">Preprocessors</a></li></ul></nav></header><div class="spec module" id="module-A"><a href="#module-A" class="anchor"></a><code><span class="keyword">module</span> A = <a href="../index.html#module-A">A</a></code></div><div class="spec module" id="module-CC_A"><a href="#module-CC_A" class="anchor"></a><code><span class="keyword">module</span> CC_A = <a href="../index.html#module-CC_A">CC_A</a></code></div><div class="spec module" id="module-CC"><a href="#module-CC" class="anchor"></a><code><span class="keyword">module</span> <a href="CC/index.html">CC</a> : <a href="../../../../../sidekick/Sidekick_core/index.html#module-type-CC_S">Sidekick_core.CC_S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../../../sidekick/Sidekick_core/module-type-CC_S/CC_A/index.html">CC_A</a> = <a href="index.html#module-CC_A">CC_A</a></code></div><dl><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> ty</code><code> = <a href="A/Ty/index.html#type-t">A.Ty.t</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="A/Term/index.html#type-t">A.Term.t</a></code></dt><dt class="spec type" id="type-term_state"><a href="#type-term_state" class="anchor"></a><code><span class="keyword">type</span> term_state</code><code> = <a href="A/Term/index.html#type-state">A.Term.state</a></code></dt><dt class="spec type" id="type-proof"><a href="#type-proof" class="anchor"></a><code><span class="keyword">type</span> proof</code><code> = <a href="A/Proof/index.html#type-t">A.Proof.t</a></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><h4 id="main-type-for-a-solver"><a href="#main-type-for-a-solver" class="anchor"></a>Main type for a solver</h4></dd></dl><dl><dt class="spec type" id="type-solver"><a href="#type-solver" class="anchor"></a><code><span class="keyword">type</span> solver</code><code> = <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Expl"><a href="#module-Expl" class="anchor"></a><code><span class="keyword">module</span> Expl = <a href="CC/index.html#module-Expl">CC.Expl</a></code></div><div class="spec module" id="module-N"><a href="#module-N" class="anchor"></a><code><span class="keyword">module</span> N = <a href="CC/index.html#module-N">CC.N</a></code></div><dl><dt class="spec value" id="val-tst"><a href="#val-tst" class="anchor"></a><code><span class="keyword">val</span> tst : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term_state">term_state</a></code></dt><dt class="spec value" id="val-cc"><a href="#val-cc" class="anchor"></a><code><span class="keyword">val</span> cc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="CC/index.html#type-t">CC.t</a></code></dt><dd><p>Congruence closure for this solver</p></dd></dl><dl><dt class="spec module" id="module-Lit"><a href="#module-Lit" class="anchor"></a><code><span class="keyword">module</span> <a href="Lit/index.html">Lit</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec type" id="type-lit"><a href="#type-lit" class="anchor"></a><code><span class="keyword">type</span> lit</code><code> = <a href="Lit/index.html#type-t">Lit.t</a></code></dt></dl><section><header><h4 id="simplifiers"><a href="#simplifiers" class="anchor"></a>Simplifiers</h4></header><div class="spec module" id="module-Simplify"><a href="#module-Simplify" class="anchor"></a><code><span class="keyword">module</span> <a href="Simplify/index.html">Simplify</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-simplify_hook"><a href="#type-simplify_hook" class="anchor"></a><code><span class="keyword">type</span> simplify_hook</code><code> = <a href="Simplify/index.html#type-hook">Simplify.hook</a></code></dt></dl><dl><dt class="spec value" id="val-add_simplifier"><a href="#val-add_simplifier" class="anchor"></a><code><span class="keyword">val</span> add_simplifier : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Simplify/index.html#type-hook">Simplify.hook</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-simplifier"><a href="#val-simplifier" class="anchor"></a><code><span class="keyword">val</span> simplifier : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Simplify/index.html#type-t">Simplify.t</a></code></dt><dt class="spec value" id="val-simp_t"><a href="#val-simp_t" class="anchor"></a><code><span class="keyword">val</span> simp_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a></code></dt></dl></section><section><header><h4 id="hooks-for-the-theory"><a href="#hooks-for-the-theory" class="anchor"></a>hooks for the theory</h4></header><dl><dt class="spec type" id="type-actions"><a href="#type-actions" class="anchor"></a><code><span class="keyword">type</span> actions</code></dt></dl><dl><dt class="spec value" id="val-propagate"><a href="#val-propagate" class="anchor"></a><code><span class="keyword">val</span> propagate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> reason:(unit <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list) <span>&#45;&gt;</span> <a href="A/Proof/index.html#type-t">A.Proof.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-raise_conflict"><a href="#val-raise_conflict" class="anchor"></a><code><span class="keyword">val</span> raise_conflict : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> <a href="A/Proof/index.html#type-t">A.Proof.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Give a conflict clause to the solver</p></dd></dl><dl><dt class="spec value" id="val-propagate"><a href="#val-propagate" class="anchor"></a><code><span class="keyword">val</span> propagate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list) <span>&#45;&gt;</span> unit</code></dt><dd><p>Propagate a boolean using a unit clause. <code>expl =&gt; lit</code> must be a theory lemma, that is, a T-tautology</p></dd></dl><dl><dt class="spec value" id="val-propagate_l"><a href="#val-propagate_l" class="anchor"></a><code><span class="keyword">val</span> propagate_l : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Propagate a boolean using a unit clause. <code>expl =&gt; lit</code> must be a theory lemma, that is, a T-tautology</p></dd></dl><dl><dt class="spec value" id="val-add_clause_temp"><a href="#val-add_clause_temp" class="anchor"></a><code><span class="keyword">val</span> add_clause_temp : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Add local clause to the SAT solver. This clause will be removed when the solver backtracks.</p></dd></dl><dl><dt class="spec value" id="val-add_clause_permanent"><a href="#val-add_clause_permanent" class="anchor"></a><code><span class="keyword">val</span> add_clause_permanent : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> unit</code></dt><dd><p>Add toplevel clause to the SAT solver. This clause will not be backtracked.</p></dd></dl><dl><dt class="spec value" id="val-mk_lit"><a href="#val-mk_lit" class="anchor"></a><code><span class="keyword">val</span> mk_lit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> ?&#8288;sign:bool <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dd><p>Create a literal</p></dd></dl><dl><dt class="spec value" id="val-add_lit"><a href="#val-add_lit" class="anchor"></a><code><span class="keyword">val</span> add_lit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add the given literal to the SAT solver, so it gets assigned a boolean value</p></dd></dl><dl><dt class="spec value" id="val-add_lit_t"><a href="#val-add_lit_t" class="anchor"></a><code><span class="keyword">val</span> add_lit_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> ?&#8288;sign:bool <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add the given (signed) bool term to the SAT solver, so it gets assigned a boolean value</p></dd></dl><dl><dt class="spec value" id="val-cc_raise_conflict_expl"><a href="#val-cc_raise_conflict_expl" class="anchor"></a><code><span class="keyword">val</span> cc_raise_conflict_expl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="CC/Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Raise a conflict with the given congruence closure explanation. it must be a theory tautology that <code>expl ==&gt; absurd</code>. To be used in theories.</p></dd></dl><dl><dt class="spec value" id="val-cc_find"><a href="#val-cc_find" class="anchor"></a><code><span class="keyword">val</span> cc_find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a></code></dt><dd><p>Find representative of the node</p></dd></dl><dl><dt class="spec value" id="val-cc_merge"><a href="#val-cc_merge" class="anchor"></a><code><span class="keyword">val</span> cc_merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="CC/Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Merge these two nodes in the congruence closure, given this explanation. It must be a theory tautology that <code>expl ==&gt; n1 = n2</code>. To be used in theories.</p></dd></dl><dl><dt class="spec value" id="val-cc_merge_t"><a href="#val-cc_merge_t" class="anchor"></a><code><span class="keyword">val</span> cc_merge_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="CC/Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Merge these two terms in the congruence closure, given this explanation. See <a href="index.html#val-cc_merge"><code>cc_merge</code></a></p></dd></dl><dl><dt class="spec value" id="val-cc_add_term"><a href="#val-cc_add_term" class="anchor"></a><code><span class="keyword">val</span> cc_add_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a></code></dt><dd><p>Add/retrieve congruence closure node for this term. To be used in theories</p></dd></dl><dl><dt class="spec value" id="val-on_cc_merge"><a href="#val-on_cc_merge" class="anchor"></a><code><span class="keyword">val</span> on_cc_merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="CC/index.html#type-t">CC.t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="CC/Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Callback for when two classes containing data for this key are merged</p></dd></dl><dl><dt class="spec value" id="val-on_cc_new_term"><a href="#val-on_cc_new_term" class="anchor"></a><code><span class="keyword">val</span> on_cc_new_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="CC/index.html#type-t">CC.t</a> <span>&#45;&gt;</span> <a href="CC/N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Callback to add data on terms when they are added to the congruence closure</p></dd></dl><dl><dt class="spec value" id="val-on_cc_conflict"><a href="#val-on_cc_conflict" class="anchor"></a><code><span class="keyword">val</span> on_cc_conflict : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="CC/index.html#type-t">CC.t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Callback called on every CC conflict</p></dd></dl><dl><dt class="spec value" id="val-on_cc_propagate"><a href="#val-on_cc_propagate" class="anchor"></a><code><span class="keyword">val</span> on_cc_propagate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="CC/index.html#type-t">CC.t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> (unit <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> list) <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Callback called on every CC propagation</p></dd></dl><dl><dt class="spec value" id="val-on_partial_check"><a href="#val-on_partial_check" class="anchor"></a><code><span class="keyword">val</span> on_partial_check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> Iter.t <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Register callbacked to be called with the slice of literals newly added on the trail.</p><p>This is called very often and should be efficient. It doesn't have to be complete, only correct. It's given only the slice of the trail consisting in new literals.</p></dd></dl><dl><dt class="spec value" id="val-on_final_check"><a href="#val-on_final_check" class="anchor"></a><code><span class="keyword">val</span> on_final_check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> Iter.t <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Register callback to be called during the final check.</p><p>Must be complete (i.e. must raise a conflict if the set of literals is not satisfiable) and can be expensive. The function is given the whole trail.</p></dd></dl></section><section><header><h4 id="preprocessors"><a href="#preprocessors" class="anchor"></a>Preprocessors</h4><p>These preprocessors turn mixed, raw literals (possibly simplified) into literals suitable for reasoning. Typically some clauses are also added to the solver.</p></header><dl><dt class="spec type" id="type-preprocess_hook"><a href="#type-preprocess_hook" class="anchor"></a><code><span class="keyword">type</span> preprocess_hook</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> mk_lit:(<a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a>) <span>&#45;&gt;</span> add_clause:(<a href="index.html#type-lit">lit</a> list <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> option</code></dt><dd><p>Given a term, try to preprocess it. Return <code>None</code> if it didn't change. Can also add clauses to define new terms.</p></dd></dl><dl><dt class="spec value" id="val-add_preprocess"><a href="#val-add_preprocess" class="anchor"></a><code><span class="keyword">val</span> add_preprocess : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-preprocess_hook">preprocess_hook</a> <span>&#45;&gt;</span> unit</code></dt></dl></section></div></body></html>